<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-pa-experimental-record-(pa2.1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/pa-experimental-record-(pa2.1)/" class="article-date">
  <time datetime="2017-03-28T14:50:33.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/pa-experimental-record-(pa2.1)/">PA实验记录（PA2.1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="cpu-模拟（src-monitor-cpu-exec-c）"><a href="#cpu-模拟（src-monitor-cpu-exec-c）" class="headerlink" title="cpu 模拟（src/monitor/cpu-exec.c）"></a>cpu 模拟（src/monitor/cpu-exec.c）</h3><ul>
<li><p>通过cpu_exec() 函数模拟cpu执行，cpu.eip指向当前要执行的指令地址。</p>
</li>
<li><p>传入exec()函数进行取指、译码、执行。函数返回指令长度（因为指令的长短不一）</p>
</li>
<li><p>cpu.eip加上执行过的指令的长度指向下一条指令。</p>
<h3 id="exec-函数细节（src-cpu-exec-exec-c）"><a href="#exec-函数细节（src-cpu-exec-exec-c）" class="headerlink" title="exec()函数细节（src/cpu/exec/exec.c）"></a>exec()函数细节（src/cpu/exec/exec.c）</h3></li>
<li><p>exec()利用宏make_helper定义。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> make_helper(name) int name(swaddr_t eip)</span></div></pre></td></tr></table></figure>
</li>
<li><p>exec()函数内部先通过fetch_instr(eip, 1)取得指令的第一个字节即opcode（操作码）</p>
</li>
<li><p>通过opcode在opcode_talbe找到对应指令的模拟函数的函数名，对应模拟函数执行在 指令.c 文件中</p>
</li>
<li><p>模拟函数利用宏make_helper_v（看名字都应该知道是make_helper的加强版,name_v）程序生成对应函数名并调用函数</p>
</li>
<li><p>函数的具体实现在指令-template.h文件中，do_execute() 是主要的执行代码，其它都是一大堆宏定义用来定义名字的。。这样你就可以用两个文件写完所有mov指令</p>
</li>
<li><p>又有一个宏make_instr_helper(name),额，do_execute也是个宏 -。-</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> make_instr_helper(type) \</span></div><div class="line">  make_helper(concat5(instr, _, type, _, SUFFIX)) &#123; \</div><div class="line">    return idex(eip, concat4(decode_, type, _, SUFFIX), do_execute); \</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>idex函数内才是真正真的译码 decode 和执行 execute </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/pa-experimental-record-(pa2.1)/" data-id="cj0tnwh490001tcw5itpcsfh3" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PA/">PA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-html5-semantic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/html5-semantic/" class="article-date">
  <time datetime="2017-03-28T14:48:24.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>►<a class="article-category-link" href="/categories/programming/frontend/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/html5-semantic/">html5语义化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="0x00-啥是语义化？"><a href="#0x00-啥是语义化？" class="headerlink" title="0x00 啥是语义化？"></a>0x00 啥是语义化？</h1><p>我现在的理解是，通过运用语义标签，让一个网页更像一个文档而不是杂乱的元素拼接。它的最终目的就是让程序员、浏览器、搜索引擎和其他的硬件设备等都可以更好的理解这个网页。<br>当我们去掉一个充满绚丽特效的页面的css后，我们会看到这个页面是不是一个文档！对于一个期望在前端有所成就的人来说，在学习如何实现各种炫丽特效的同时，也要注重html的文档结构。强健的结构才是一个网页根本。  </p>
<h1 id="0x01-语义标签"><a href="#0x01-语义标签" class="headerlink" title="0x01 语义标签"></a>0x01 语义标签</h1><p>在html5标准出来之前，我们最喜欢用div标签来布局。</p>
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;

&lt;title&gt;exam&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;

&lt;divclass=&quot;header&quot;&gt;&lt;/div&gt;

&lt;divclass=&quot;content&quot;&gt;&lt;/div&gt;

&lt;divclass=&quot;footer&quot;&gt;&lt;/div&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>这样写程序员理解起来确实已经很友好了，但对搜索引擎，电子阅读器等设备来说还是不够，因为它们依然不理解你写的是什么，在它们眼中，这依然是三个毫无意义的div。<br>现在我们有了更好的选择。  </p>
<h2 id="lt-header-gt"><a href="#lt-header-gt" class="headerlink" title="&lt;header&gt;"></a><code>&lt;header&gt;</code></h2><p><code>&lt;header&gt;</code>元素有两种使用方式。一是用来标注内容的标题，另一种是用它标注网页的页眉。但有的时候到底该不该用<code>&lt;header&gt;</code>并不十分明确，有一个简单的准则：只有内容标题还附带了其他信息的情况下，才有必要考虑<code>&lt;header&gt;</code>。比如包含了标题、概要、发表日期、作者署名、图片或子主题链接等。  </p>
<h2 id="lt-nav-gt-和-lt-aside-gt"><a href="#lt-nav-gt-和-lt-aside-gt" class="headerlink" title="&lt;nav&gt; 和 &lt;aside&gt;"></a><code>&lt;nav&gt;</code> 和 <code>&lt;aside&gt;</code></h2><p>在以前，我们大多把导航栏，侧边栏放在一个div中，现在我们有了新的选择。<br><code>&lt;aside&gt;</code>表示独立于页面主内容的一个完整的内容块。<br><code>&lt;nav&gt;</code>则用于包装一组链接。这些链接可以指向当前页面中的主题，也可以指向其他页面。一个页面中可能有多个<code>&lt;nav&gt;</code>区块，但不是所有链接都需要<code>&lt;nav&gt;</code>区块。比如页面中比较零散的链接就完全没有必要使用<code>&lt;nav&gt;</code>。</p>
<h2 id="lt-article-gt"><a href="#lt-article-gt" class="headerlink" title="&lt;article&gt;"></a><code>&lt;article&gt;</code></h2><p>这个元素表示一个完整的、自成一体的内容块，比如博客文章或新闻报道。<code>&lt;article&gt;</code>元素应该包含所有相关的内容，包括标题、作者署名以及正文。有的时候一个页面就是一个article，有的时候多个article组成一个页面。  </p>
<h2 id="lt-figure-gt"><a href="#lt-figure-gt" class="headerlink" title="&lt;figure&gt;"></a><code>&lt;figure&gt;</code></h2><p>在一篇文档中，经常需要添加插图。以前我们可能这样写：  </p>
<pre><code>&lt;divclass=&quot;FloatFigure&quot;&gt;

&lt;imgsrc=&quot;exam.jpg&quot;alt=&quot;exam&quot;&gt;

&lt;p&gt;这仅是个例子&lt;/p&gt;

&lt;/div&gt;
</code></pre><p>为了让它看起来更像个插图。我们可以添加一些css样式：</p>
<pre><code>.FloatFigure&amp;#123;

float:left;

margin:020px00;

&amp;#125;

.FloatFigurep&amp;#123;

max-width:200px;

font-size:small;

font-style:italic;

margin-bottom: 5px;

&amp;#125;
</code></pre><p>现在有了更好的解决办法：</p>
<pre><code>&lt;figure&gt;

&lt;imgsrc=&quot;exam&quot;&gt;

&lt;figcaption&gt;这仅是个例子&lt;/figcaption&gt;

&lt;/figure&gt;
</code></pre><h2 id="lt-footer-gt"><a href="#lt-footer-gt" class="headerlink" title="&lt;footer&gt;"></a><code>&lt;footer&gt;</code></h2><p>这个元素和<code>&lt;header&gt;</code>不同，在现在的标准中，只能放一些网站版权信息、作品来源、法律限制及链接之类的信息。不能在<code>&lt;footer&gt;</code>里面放太多链接、重要的内容或无关的内容。</p>
<h2 id="lt-main-gt"><a href="#lt-main-gt" class="headerlink" title="&lt;main&gt;"></a><code>&lt;main&gt;</code></h2><p><code>&lt;main&gt;</code>元素用来标识网页的主要内容，它对样式不会产生任何影响。但不要把<code>&lt;main&gt;</code>元素嵌套在<code>&lt;article&gt;</code>元素里。因为<code>&lt;main&gt;</code>元素用来标识页面的重要内容而不是用来标记内容的重要段落的。<code>&lt;main&gt;</code>元素对屏幕阅读器很重要，它可以让屏幕阅读器直达主要内容。</p>
<h1 id="0x02-结语"><a href="#0x02-结语" class="headerlink" title="0x02 结语"></a>0x02 结语</h1><p>语义化是个痛苦的过程，它要求我们必须能够很好的对页面进行结构划分。在最开始我们需要花费更多的时间去甄选标签，同时，html是一门活着的语言，它的标准在不断的改变。但不管怎么变，文档结构不会变。只要能够对文档进行最优的划分，语义化也就是熟练运用标签吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/html5-semantic/" data-id="cj0tnwh4r0005tcw5b5iy3lv0" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5/">html5</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dom-event-study-notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/dom-event-study-notes/" class="article-date">
  <time datetime="2017-03-28T14:45:16.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>►<a class="article-category-link" href="/categories/programming/frontend/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/dom-event-study-notes/">DOM事件学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p>HTML 和 Javascript 之间的交互式通过事件完成的。事件就是文档或浏览器窗口发生的一些特定的交互瞬间。我们可以给元素绑定事件响应程序以此来完成我们想要实现的交互动作。  </p>
<h1 id="0x01-事件流"><a href="#0x01-事件流" class="headerlink" title="0x01 事件流"></a>0x01 事件流</h1><p>当我们鼠标点击一个按钮时，被点击的只有这个按钮吗？包含这个按钮的父元素、整个body是不是也被点击了？答案是肯定的。那么下一个问题，是先点到外围的元素还是先点到最中心的元素（我们真正想要的点到元素）？对于这个问题，网景和IE给出了截然相反的定义。即事件冒泡和事件捕获。</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>当我们点击一个元素时，点击事件先在这个元素触发事件处理程序，然后这个事件向它的父元素传递，依次向外，就像从水底冒起的水泡，逐渐变大！这就是微软定义的事件冒泡流。</p>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>与事件冒泡相反，事件捕获流中，事件先从“最大的元素” window 被触发，然后逐渐向内传递，直到最后。就像逐渐收缩的网捕获住真正触发事件的元素。</p>
<h2 id="DOM2级事件流"><a href="#DOM2级事件流" class="headerlink" title="DOM2级事件流"></a>DOM2级事件流</h2><p>W3C给出的DOM2级标准中规定，任何一个元素触发事件都要经历三个阶段：事件捕获———处于目标———事件冒泡。W3C完美的解决了双方的矛盾。。。。  </p>
<h1 id="0x02-事件处理程序"><a href="#0x02-事件处理程序" class="headerlink" title="0x02 事件处理程序"></a>0x02 事件处理程序</h1><p>事件发生后，被触发的就是事件处理程序。给一个元素绑定一个事件处理程序有多种方法。  </p>
<h2 id="HTML事件绑定"><a href="#HTML事件绑定" class="headerlink" title="HTML事件绑定"></a>HTML事件绑定</h2><pre><code>&lt;buttononclick=&quot;aciton();&quot;&gt;&lt;/button&gt;
</code></pre><p>这种方法简单易行，浏览器都能支持。但是时间处理程序和元素太过紧密，修改起来及其不方便。</p>
<h2 id="DOM0-级事件绑定"><a href="#DOM0-级事件绑定" class="headerlink" title="DOM0 级事件绑定"></a>DOM0 级事件绑定</h2><pre><code>&lt;buttonid=&quot;btn&quot;&gt;&lt;/button&gt;

&lt;script&gt;

    var elem = document.getElementById(&apos;btn&apos;);

    elem.onclick = function()&amp;#123;

      ......  

    &amp;#125;;

&lt;/script&gt;
</code></pre><p>DOM0 级事件都是”on”+事件名的形式，比如 onclick、onmourseover等等。在一定程度上降低了元素和事件处理程序的耦合度。这样绑定的事件是可以取消的。即给同一个元素的同一个事件赋值 null，就可以覆盖掉前面绑定的事件。</p>
<h2 id="DOM2-级事件绑定"><a href="#DOM2-级事件绑定" class="headerlink" title="DOM2 级事件绑定"></a>DOM2 级事件绑定</h2><p>DOM2 级的事件绑定引入事件监听器。可以规定元素是进行事件冒泡还是事件捕获。  </p>
<pre><code>&lt;buttonid=&quot;btn&quot;&gt;&lt;/button&gt;

&lt;script&gt;

    var elem = document.getElementById(&apos;btn&apos;);

    function aciton (event) &amp;#123;

        ...

    &amp;#125;;

    elem.addEventListener(&quot;click&quot;, action, false);

    //false 代表进行事件冒泡

&lt;/script&gt;
</code></pre><p>另外，事件监听器还可以给同一个元素的同一个事件添加多个处理程序，事件触发时，会按绑定时的先后顺序依次执行。（ie9以下不支持addEventListener方法，可以使用jquery，或者自己封装一个对象。）</p>
<p>取消事件则是用removeEventListener方法，如果绑定的是个匿名函数则不能取消。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/dom-event-study-notes/" data-id="cj0tnwh4t0006tcw5pbmbsp1s" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js-the-aces-child-node-childnodes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/js-the-aces-child-node-childnodes/" class="article-date">
  <time datetime="2017-03-28T14:41:57.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>►<a class="article-category-link" href="/categories/programming/frontend/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/js-the-aces-child-node-childnodes/">js之访问子节点childNodes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>昨天在群里，有个部门干事问了一个关于childNodes的问题。这是他的html代码:</p>
<pre><code>&lt;ul&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;/ul&gt;
</code></pre><blockquote>
<p>为什么childNode[0].nodeName返回的结果是#text，而不是li?  </p>
</blockquote>
<p>正好前两天在慕课网上复习js的一些基础知识时，复习到了这个知识点。现在总结一下。  </p>
<h1 id="0x01-childNodes属性的相关知识"><a href="#0x01-childNodes属性的相关知识" class="headerlink" title="0x01 childNodes属性的相关知识"></a>0x01 childNodes属性的相关知识</h1><p>从字面意思上就可以知道，这个属性是来获取当前结点的所有子节点的。</p>
<pre><code>1



elementNode.childNodes
</code></pre><p>它的返回值不是一个数组，而是一个NodeList对象，它具有length属性，也可以通过索引来进行调用。</p>
<h1 id="0x02-出现偏差的原因"><a href="#0x02-出现偏差的原因" class="headerlink" title="0x02 出现偏差的原因"></a>0x02 出现偏差的原因</h1><p>其实很简单，DOM节点有三种：元素节点、文本节点和属性节点。在firefox、chrome、opera、safari浏览器中元素节点之间的空白字符会生成文字节点。所以ul的子节点不仅仅有li这种元素节点而且会有很多空白字符生成的文本节点。因此需要我们在处理之前通过nodeType属性把非元素节点过滤掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/js-the-aces-child-node-childnodes/" data-id="cj0tnwh54000atcw57acioj8i" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-a-comand" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/a-comand/" class="article-date">
  <time datetime="2017-03-28T14:38:21.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>►<a class="article-category-link" href="/categories/programming/security/">安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/a-comand/">一条命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="echo-“bnVhYWN0ZiU3Qi93ZWIyL2NlYmE2ZmJiZjBlZGU0MzI1MjY0MWNkMzM2ZTM2YTAzJTdE”-base-d-gt-out-dat"><a href="#echo-“bnVhYWN0ZiU3Qi93ZWIyL2NlYmE2ZmJiZjBlZGU0MzI1MjY0MWNkMzM2ZTM2YTAzJTdE”-base-d-gt-out-dat" class="headerlink" title="echo “bnVhYWN0ZiU3Qi93ZWIyL2NlYmE2ZmJiZjBlZGU0MzI1MjY0MWNkMzM2ZTM2YTAzJTdE” | base -d &gt; out.dat"></a>echo “bnVhYWN0ZiU3Qi93ZWIyL2NlYmE2ZmJiZjBlZGU0MzI1MjY0MWNkMzM2ZTM2YTAzJTdE” | base -d &gt; out.dat</h2><h3 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h3><p>在Linux中echo命令用来在标准输出上显示一段字符。例如：</p>
<pre><code>echo &quot;I love you!&quot;
</code></pre><p>那么在终端就会输出</p>
<pre><code>I love you!
</code></pre><p>基本语法：echo [-ne][字符串]<br>参数的含义：<br>-n 不要再最后做换行处理(默认换行).<br>-e 如果字符串出现以下字符则做特殊处理，而不是当作一般字符串输出。<br>字符处理方式\a发出警告声\b删除前一个字符\c最后不加上换行符号\f换行但光标仍旧停留在原来的位置\n换行且光标移至行首\r光标移至行首，但不换行\t插入tab\v与\f相同\插入\字符\nnn插入nnn（八进制）所代表的ASCII字符</p>
<h3 id="管道（pipeline）"><a href="#管道（pipeline）" class="headerlink" title="| 管道（pipeline）"></a>| 管道（pipeline）</h3><p>连结上个指令的标准输出，做为下个指令的标准输入。</p>
<h3 id="base64-命令"><a href="#base64-命令" class="headerlink" title="base64 命令"></a>base64 命令</h3><p>从标准输入中读取数据，并做base64编码的相关处理。</p>
<p>常用方式<br>格式描述base64从标准输入中读取数据并编码为base64字符串输出base64 file从指定的文件file中读取数据，编码为base64字符串输出base64 -d从标准输入中读取已经进行base64编码的内容，解码输出base64 -d -i从标准输入中读取已经进行base64编码的内容，解码输出。加上-i参数，忽略非字母表字符，比如换行符</p>
<h3 id="cmd-gt-file"><a href="#cmd-gt-file" class="headerlink" title="cmd &gt; file"></a>cmd &gt; file</h3><p>把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件。</p>
<h2 id="file-out-dat"><a href="#file-out-dat" class="headerlink" title="file out.dat"></a>file out.dat</h2><p>该命令用来识别文件类型，也可用来辨别一些文件的编码格式。它是通过查看文件的头部信息来获取文件类型，而不是像Windows通过扩展名来确定文件类型的。  </p>
<p>几个常用参数：<br>参数描述-b列出文件辨识结果时，不显示文件名称-c详细显示指令执行过程，便于排错或分析程序执行的情形-f列出文件中文件名的文件类型-F使用指定分隔符号替换输出文件名后的默认的“：”分隔符-i输出mime类型的字符串-L查看对应软链接对应文件的文件类型-z尝试去解读压缩文件的内容</p>
<h2 id="base64-编码和-URL-编码"><a href="#base64-编码和-URL-编码" class="headerlink" title="base64 编码和 URL 编码"></a>base64 编码和 URL 编码</h2><p>base64 编码是用64个可打印字符来表示二进制数据的表示方法。  </p>
<p>当你对一个字符串进行base64编码时，就是把字符串对应的二进制数据流每6位分成一组，根据base64编码表，转化成对应字符输出。如果最后不够六位，会用0补足，并在编码后的结果中添加“=”来表示补足了几位。补足两位，加一个 “=”，四位则加两个等号。  </p>
<p>URL 就是网址，一般来说，URL只能使用英文字母，阿拉伯数字和某些标点。对于汉字和一些特殊字符就要进行URL编码。但对URL的编码规则往往会因为使用场景和浏览器的不同而出现差异，所以我们一般都在js中先对URL进行统一的编码。</p>
<p>两个编码函数：  </p>
<p>encodeURI() ：它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。  对应解码函：decodeURI()。</p>
<p>encodeURIComponent() ：与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。<br>因此，”; / ? : @ &amp; = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。对应解码函数：decodeURIComponent()。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/a-comand/" data-id="cj0tnwh5b000ctcw5s27un4nm" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/">ctf</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux-study-notes-of-the-past-life-of-linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/linux-study-notes-of-the-past-life-of-linux/" class="article-date">
  <time datetime="2017-03-28T14:31:53.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/linux-study-notes-of-the-past-life-of-linux/">Linux学习笔记之Linux的前世今生</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a><a href="#Linux是什么" title="Linux是什么"></a>Linux是什么</h2><p>我们知道，计算机是由一堆硬件组成的，为了更有效地控制这些硬件资源，于是乎就有了操作系统的产生了。操作系统不仅可以有效地控制这些硬件资源，并提供计算机运行所需要的功能（如网络功能），而且提供了一整组系统调用接口来给程序员开发用，为程序员提供了更容易开发软件的环境。<br><strong>而Linux就是是一套操作系统</strong> 。它提供了一个完整的操作系统当中最底层的硬件控制与资源管理的完整架构。这个架构师沿袭UNIX良好的传统而来的，所以它相当的稳定和强大。Linux作为一款操作系统，更多的是给开发人员用的。而为人熟知的Windows操作系统则是面向普通大众的。</p>
<h2 id="Linux之前UNIX的历史"><a href="#Linux之前UNIX的历史" class="headerlink" title="Linux之前UNIX的历史"></a><a href="#Linux之前UNIX的历史" title="Linux之前UNIX的历史"></a>Linux之前UNIX的历史</h2><p>前面说Linux是一套强大稳定的操作系统，而它这项特性更多地市继承自早它20年出现的 <strong>UNIX</strong> （一个相当稳定而成熟的操作系统）。下面我们先以时间轴的形式了解一下UNIX。</p>
<h4 id="1969年之前：一个伟大的梦想——“Multics”系统"><a href="#1969年之前：一个伟大的梦想——“Multics”系统" class="headerlink" title="1969年之前：一个伟大的梦想——“Multics”系统"></a><a href="#1969年之前：一个伟大的梦想——“Multics”系统" title="1969年之前：一个伟大的梦想——“Multics”系统"></a>1969年之前：一个伟大的梦想——“Multics”系统</h4><p>在计算机世界的原始社会中，计算机并不像现在一样普及。除非是军事或者是高科技用途，或者是学术院校的学术研究，否则真的很难接触到计算机。而且早期计算机架构复杂难用，输入设备只有卡片阅读机，输出设备只有打印机。编写程序是一件机器麻烦的事情。而且主机少，用户多，仅是排队就会耗去很多时间。<br>虽然在后来可以使用键盘来输入信息，但依然没有解决用户多，主机少的矛盾。好在20世纪60年代初期，MIT开发了分时操作系统（Compatible Time-sharing System）,它可以让大型主机通过提供多个终端机（Terminal）以连接进入主机，从而利用主机的资源进行运算工作。但是比较先进的主机也只能提供30台左右的终端机而已。<br>为了加强大型主机的功能，以便让主机的资源可以被更多的用户利用。在1965年，由贝尔实验室（Bell）、麻省理工学院（MIT）以及通用电气公司（GE）共同发起了Multics项目。Multics项目的目的是想让大型主机可以同时提供300台以上的终端机直接使用。不过到了1969年前后，因为种种原因，Bell退出了该项目。</p>
<h4 id="1969年：ken-Thompson的小型-File-Server-System"><a href="#1969年：ken-Thompson的小型-File-Server-System" class="headerlink" title="1969年：ken Thompson的小型 File Server System"></a><a href="#1969年：ken-Thompson的小型-File-Server-System" title="1969年：ken Thompson的小型 File Server System"></a>1969年：ken Thompson的小型 File Server System</h4><p>在认为Multics项目不可能成功之后，Bell退出了该项目。不过，原本参与该项目的一些人员，已经从该项目中获得了一些想法，Ken Thompson 就是其中一位。<br>Thompson为了满足自己的一个需求，希望开发一个小的操作系统。在开发时，正好有一台DEC（Digital Equipment Corporation）公司推出的PDP-7刚好没人使用，于是他就准备针对这部主机进行操作系统内核程序的编写。经过四周的奋战，他终于用汇编语言写出了一组内核程序，同时包括一些内核工具程序，以及一个小的文件系统。这就是UNIX的原型。由于这个系统比Multics简单小巧很多，于是Thompson的同实验室的朋友都戏称这个系统为Unics。<br>Thompson这个文件系统有两个重要的概念：</p>
<ul>
<li>所有的程序或系统装置都是文件。</li>
<li>不管构建编辑器还是附属文件，所写的程序只有一个目的，就是要有效地完成目标。</li>
</ul>
<p>这两条对后来Linux的开发有着相当重要的影响。</p>
<h4 id="1973年：UNIX正式诞生，Ritchie等人以C语言写出了第一个正式UNIX内核"><a href="#1973年：UNIX正式诞生，Ritchie等人以C语言写出了第一个正式UNIX内核" class="headerlink" title="1973年：UNIX正式诞生，Ritchie等人以C语言写出了第一个正式UNIX内核"></a><a href="#1973年：UNIX正式诞生，Ritchie等人以C语言写出了第一个正式UNIX内核" title="1973年：UNIX正式诞生，Ritchie等人以C语言写出了第一个正式UNIX内核"></a>1973年：UNIX正式诞生，Ritchie等人以C语言写出了第一个正式UNIX内核</h4><p>由于Thompson写的这个操作系统实在是太好用了，所以在Bell内广为流传，并经过了多次改版。但是Unics本来是以汇编语言写成的，而汇编语言具有一定的专一性，加上当时的计算机机器架构都不太相同，所以每次安装到不同的机器都得要重新编写汇编语言，真的很麻烦。<br>后来呢Thompson与Ritchie合作想用Unics改以更高级的程序语言来编写。当时现成的高级语言有B语言，但由B语言编译出来的内核性能不是很好。后来Dennis Ritchie 将B语言重新改写成C语言，再以C语言重新改写与编译Unics的内核，最后发行出UNIX的正式版本。<br>需要特别强调的是，C语言作为一种高级程序语言，与硬件的相关性就没有那么大了！所以，用C语言改写和编译的UNIX很容易被移植到不同的机器上。</p>
<h4 id="1977年：重要的UNIX分支——BSD诞生"><a href="#1977年：重要的UNIX分支——BSD诞生" class="headerlink" title="1977年：重要的UNIX分支——BSD诞生"></a><a href="#1977年：重要的UNIX分支——BSD诞生" title="1977年：重要的UNIX分支——BSD诞生"></a>1977年：重要的UNIX分支——BSD诞生</h4><p>我们还需要知道的一点是，Bell是隶属于美国电信大厂AT&amp;T公司，只是AT&amp;T当时忙于其他商业活动，对于UNIX的态度相对开放，既不支持，也不排斥。再加上UNIX的可移植性，在1973年以后，UNIX便得以和学术界合作开发。最重要的接触就是和加州柏克莱大学的合作了。<br>柏克莱大学的Bill Joy 在取得UNIX的内核源码以后，着手修改成适合自己适合自己机器的版本，并且同时增加了很多工具软件和编译程序，最终将他命名为 Berkeley Software Distribution（BSD）.这个BSD是UNIX很重要的一个分支，Bill joy 也是Sunday这家公司的创办者。Sun公司即是以BSD开发的内核进行自己的商业UNIX版本的开发的。（后来可以安装在X86硬件架构上面FreeBSD即是BSD改版而来！）</p>
<h4 id="1979年：重要的-System-V-架构-与版权声明"><a href="#1979年：重要的-System-V-架构-与版权声明" class="headerlink" title="1979年：重要的 System V 架构 与版权声明"></a><a href="#1979年：重要的-System-V-架构-与版权声明" title="1979年：重要的 System V 架构 与版权声明"></a>1979年：重要的 System V 架构 与版权声明</h4><p>由于UNIX的高度可移植性和强大的性能，加上当时没有版权区分，所以很多商业公司开始了UNIX操作系统开发，例如，AT&amp;T自家的System V、IBM的AIX以及HP与DEC等公司，都推自家的主机搭配自己的UNIX操作系统。但是却没有一家厂商针对个人计算机设计UNIX系统。原因是UNIX强调的是多用户、多任务的环境，但早期的286个人计算机架构下的CPU是没有能力进行多任务的作业。因此，早先的UNIX只能与服务器或者大型工作站划上等号。但到了1979年时，AT&amp;T推出的 System V 第七版UNIX后，这个情况就有点改善了。这一版本的特性就是可以支持x86架构的个人计算机系统。<br>不过AT&amp;T出于商业的考虑，以及在当时现实环境下的思考，想将UNIX的版权收回。因此，在1979年发布新版本的同时，特别提到了“不可对学生提供源码”的严格限制。并且也引发了很多商业纠纷。</p>
<h4 id="1984年之一：x86架构的Minix操作系统诞生"><a href="#1984年之一：x86架构的Minix操作系统诞生" class="headerlink" title="1984年之一：x86架构的Minix操作系统诞生"></a>1984年之一：x86架构的Minix操作系统诞生</h4><p>受1979年版权声明影响最大的是在学校里教导UNIX内核源码相关知识的教授们。不能向学生展示源码还怎么教学？这个问题让谭宁邦教授很伤脑筋。于是，谭宁邦教授自己编写了Minix这个UNIX like的内核程序。在编写过程中为了避免版权纠纷，谭宁邦教授完全不看UNIX的源码，从1984年开始编写，并于1986年完成，在次年也出版了Minix的相关书籍。之所以叫Minix，是因为它是一个mini的UNIX系统，是可以运行在x86架构的机器上的。但是Minix的开发者只有谭宁邦教授一个人，由于他本人学术繁忙，加上他本人也始终认为Minix主要用在教育上面，所以对于Minix是点到为止。Minix虽然很受欢迎，但很难去满足用户更高的需求。</p>
<h4 id="1984年之二：GNU项目与FSF基金会成立"><a href="#1984年之二：GNU项目与FSF基金会成立" class="headerlink" title="1984年之二：GNU项目与FSF基金会成立"></a>1984年之二：GNU项目与FSF基金会成立</h4><p>Richard Mathew Stallman（史托曼）在1984年发起的GNU项目，对于现今的自由软件风潮有着不可磨灭的地位。目前我们使用的很多自由软件，几乎均直接或间接受益于GNU这个项目，那么史托曼是何许人也？他为何会发起这个GNU项目呢？</p>
<p>当时的黑客圈对于软件的着眼点几乎都是在“分享”，所以没有专利方面的困扰（当时的黑客指的是计算机功力很强的人，并不是指那些破坏计算机的骇客）。而史托曼深受这个特色的影响。尽管越来越多的黑客进入商业公司开发优秀的软件，但史托曼依然坚持着黑客的信仰，但他很快发现，自己一个人无法完成所有的工作，于是想成立一个开放的团队来共同努力。<br>1984年，史托曼开始GNU项目，这个项目的目的是创建一个自由、开放的UNIX操作系统（Free UNIX）。但是开发一款操作系统并不是一件很容易的事，而且当时的GNU只有史托曼一个人单打独斗，这实在是难上加难，但他又不想放弃这个项目。于是，史托曼另辟蹊径，先模仿其他运行在UNIX上的软件，开发了很多具有相同功能的软件，为了避免版权纠纷，开发期间，史托曼绝不看其他软件的任何源码。后来一堆人知道了免费的GNU软件，并且在实际使用后发现和其他专利软件差不多，便转而使用GNU软件，GNU项目也逐渐有了知名度。<br>但GNU的曝光度依然不够，于是史托曼就想开发一款大家都需要的软件，没错，就是编译器。任何程序都需要编译成二进制文件才可以运行。因此史托曼便开始编写C语言的编译程序，就是现在相当有名的GCC（GNU C Compiler）。但开始编写GCC的时候并不顺利，于是他先转而将他原先已经写过的Emacs编辑器写成可以在UNIX上运行的软件，并公布源码。Emacs是一款强大的编辑器，他可以在用户编写程序的过程中就进行程序语法的箴言，这个功能可以减少程序员的排错时间！此时的互联网还没有流行，所以，史托曼借着出售优秀的Emacs赚了一点钱，从而开始专心开发其他软件，并成立了 <strong>自由软件基金会（Free SoftWare Foundation，FSF）</strong> , 请更多工程师与志愿者来编写软件。终于还是完成了GCC，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/linux-study-notes-of-the-past-life-of-linux/" data-id="cj0tnwh4o0004tcw5mht0pij0" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript-study-notes-some-basic-concepts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/javascript-study-notes-some-basic-concepts/" class="article-date">
  <time datetime="2017-03-28T13:58:48.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>►<a class="article-category-link" href="/categories/programming/frontend/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/javascript-study-notes-some-basic-concepts/">JavaScript学习笔记之温习一些基本概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><a href="#语法" title="语法"></a>语法</h3><hr>
<blockquote>
<p>ECMAScript的语法大量借鉴了C及其他类C语言（如Jave和Perl）的语法。</p>
</blockquote>
<h4 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a><a href="#区分大小写" title="区分大小写"></a>区分大小写</h4><p>ECMAScript中的一切都是区分大小写的。<code>test</code>和<code>Test</code>是两个不一样的变量名</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a><a href="#标识符" title="标识符"></a>标识符</h4><p>标识符是指变量、函数、属性的名字，或者是函数的参数。标识符的书写规则：</p>
<p>1.第一个字符必须是一个字母、下划线（_）或一个美元符号（$）。</p>
<p>2.其他字符可以是字母、下划线、美元符号或数字。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a href="#注释" title="注释"></a>注释</h4><p>EMCAScript的注释使用C风格的注释</p>
<pre><code>//单行注释

/*
 *多行注释
 */
</code></pre><h4 id="语句形式"><a href="#语句形式" class="headerlink" title="语句形式"></a><a href="#语句形式" title="语句形式"></a>语句形式</h4><p>EMCAScript的语句以一个分号结尾，如果没有分号则由解析器确定语句的结尾。虽然分号没有被强制要求。但在每一句语句后添加表示结尾依然被推荐，这样可以放心的省区空格换行等以压缩代码。</p>
<h4 id="严格模式（strict-mode）"><a href="#严格模式（strict-mode）" class="headerlink" title="严格模式（strict mode）"></a><a href="#严格模式（strict-mode）" title="严格模式（strict mode）"></a>严格模式（strict mode）</h4><p>ECMAScript 5引入了严格模式的概念。严格模式是为Javascript定义了一种不同的解析与执行模型。启用严格模式后，EMCAScript 3中的一些不确定行为将得到处理，而且对某些不安全操做也会抛出错误。要在整个脚本中启用严格模式，可在顶部添加如下代码：<br><code>&quot;use strict&quot;:</code></p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a><a href="#关键字和保留字" title="关键字和保留字"></a>关键字和保留字</h3><hr>
<p>EMCA-262规定了一组具有特殊用途的<strong>关键字</strong>，这些关键字可以表示控制语句的开始或结束，或者用于执行特定的操作等。<br>EMCA-262还规定了另外一组不能用作标识符的<strong>保留字</strong>。尽管保留字在这门语言中没有任何特定的用途，但它们有可能在将来被用作关键字。<br>具体有哪些关键字可自行百度谷歌。。。。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><a href="#变量" title="变量"></a>变量</h3><hr>
<p>EMCAScript的变量是松散类型的，可以用来保存任何类型的数据。每个变量仅仅是一个用于保存值得占位符。定义变量时要使用 <code>var</code> 操作符。</p>
<pre><code>var message;  
</code></pre><p>ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值。</p>
<pre><code>var message = &quot;sky&quot;;  
</code></pre><p>像这样的初始化变量并不会把它标记为字符串类型；初始化的过程就是简单地给变量赋一个值。因此，可以在修改变量值的同时修改值得类型。</p>
<pre><code>var message = &quot;sky&quot;;
message = 1024;   //有效，但不推荐。
</code></pre><p>使用 <code>var</code> 操作符定义的变量将成为定义该变量的作用域中的局部变量。<br>可以使用一条语句定义多个变量。</p>
<pre><code>var message = &quot;sky&quot;, choice = true, age = 29;
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a href="#数据类型" title="数据类型"></a>数据类型</h3><hr>
<p>ECMAScript有五种基本数据类型：Undefined、Null、Boolean、Number、String。一种复杂类型Object，Object类型实质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型。鉴于ECMAScript是松散类型的，因此需要有一种检测给定变量的数据类型的手段——<code>typeof</code>。<br>对一个值使用<code>typeof</code>操作符可能返回下列某个字符串：</p>
<table><br><br><thead><br><br><tr><br><br><th style="text-align:center">字符串</th><br><br><th style="text-align:center">意义</th><br><br></tr><br><br></thead><br><br><tbody><br><br><tr><br><br><td style="text-align:center">undefined</td><br><br><td style="text-align:center">这个值未定义</td><br><br></tr><br><br><tr><br><br><td style="text-align:center">boolean</td><br><br><td style="text-align:center">这个值是布尔值</td><br><br></tr><br><br><tr><br><br><td style="text-align:center">string</td><br><br><td style="text-align:center">这个值是字符串</td><br><br></tr><br><br><tr><br><br><td style="text-align:center">number</td><br><br><td style="text-align:center">这个值是数值</td><br><br></tr><br><br><tr><br><br><td style="text-align:center">function</td><br><br><td style="text-align:center">这个值是函数</td><br><br></tr><br><br><tr><br><br><td style="text-align:center">object</td><br><br><td style="text-align:center">这个值是对象或null</td><br><br></tr><br><br></tbody><br><br></table>

<pre><code>var message = &quot;string&quot;;
alert(typeof message);    //&quot;string&quot;
alert(typeof (message));  //&quot;string&quot;
alert(typeof 1024);       //&quot;number&quot;
</code></pre><p>几点说明：</p>
<ol>
<li>typeof是操作符，不是函数，所以例子中的圆括号可有可无，不是必须的。</li>
<li>typeof的操作数可以是变量，也可以是数值字面量。</li>
<li>特殊值null被认为是一个空的对象引用。</li>
</ol>
<blockquote>
<p>从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。</p>
</blockquote>
<h4 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a><a href="#Undefined类型" title="Undefined类型"></a>Undefined类型</h4><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。</p>
<blockquote>
<p>一般而言，不存在需要显式地把一个变量设置为undefined值的情况。字面值undefined的主要目的是用于比较，而ECMA-262第3版之前的版本中并没有规定这个值。第3版引入这个值是为了正式区分空对象指针与未经初始化的变量。</p>
</blockquote>
<ul>
<li>注意： *对未声明的变量使用typeof操作符也会返回undefined，因此我们要养成即时为变量赋值的习惯，以此来辨别变量是未初始化还是没有声明。</li>
</ul>
<h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a><a href="#Null类型" title="Null类型"></a>Null类型</h4><p>Null类型也只有一个值，这个特殊的值是null。用注意的一点是，undefined是派生自null的，所以在ECMA-262中规定它们的相等性测试要返回true。</p>
<pre><code>alert(undefined == null); //true
</code></pre><p>上面说过，一般不会显示的声明一个变量为undefined值，但null不一样。如果要保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
<p>以上是我在看书时，觉得曾经在培训时没有注意到的一些基本概念。记下来以便日后再次查阅。</p>
<p>阅读书目：《Professional JavaScript for Web Developers》 3rd Edition 作者：Nicholas C.Zakas 译者：李松峰 曹力</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/javascript-study-notes-some-basic-concepts/" data-id="cj0tnwh450000tcw59bwf03ut" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/frontend/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/security/">安全</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PA/">PA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/PA/" style="font-size: 10px;">PA</a> <a href="/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/pa-experimental-record-(pa2.1)/">PA实验记录（PA2.1）</a>
          </li>
        
          <li>
            <a href="/2017/03/html5-semantic/">html5语义化</a>
          </li>
        
          <li>
            <a href="/2017/03/dom-event-study-notes/">DOM事件学习笔记</a>
          </li>
        
          <li>
            <a href="/2017/03/js-the-aces-child-node-childnodes/">js之访问子节点childNodes</a>
          </li>
        
          <li>
            <a href="/2017/03/a-comand/">一条命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>